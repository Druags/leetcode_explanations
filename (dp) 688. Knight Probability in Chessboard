class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        dp = [[0] * n for _ in range(n)]  # создаём список, представляющий из себя шахматное поле
        dp[row][column] = 1  # ячейку, в которой изначально стоит конь приравниваем к 1, т.к. оказаться в ней шанс 100

        moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]  # список всех возможных движений коня

        for move in range(1, k + 1):  # цикл длиной в количество шагов
            new_dp = [[0] * n for _ in range(n)]  # создаём пустую версию шахматной доски
            for r in range(n):  # цикл по строкам 
                for c in range(n):  # цикл по колонкам
                    for m in moves:  # перебираем все возможные действия
                        new_r = r + m[0]  # новая координата по строке
                        new_c = c + m[1]  # новая координата по колонке
                        if 0 <= new_r < n and 0 <= new_c < n:  # если конь остался на шахматной доске
                            new_dp[r][c] += dp[new_r][new_c] / 8.0  # в ячейку из временной шахматной доски записываем вероятность, основанную возможности попадания коня именно в эту клетку из 8 имеющихся
            dp = new_dp  # сохраняем временную доску в изначальной доске

        probability = 0.0  # верояность того, что конь останется на доске
        for r in range(n):  # складываем 
            for c in range(n):  # все 
                probability += dp[r][c]  # вероятности

        return probability  # возвращаем результирующую вероятность
                
