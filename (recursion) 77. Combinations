class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        sol=[]  # создаём список для будущих вариантов комбинаций
        def backtrack(remain,comb,nex):  # функция бэктрекинга принимает количество оставшихся чисел для полной комбинации; список, в котором хранится текущая комба; следующее число
            if remain==0:  # если числе для комбинации не осталось, 
                sol.append(comb.copy())  # то добавляем её в результат
            else:  # иначе
                for i in range(nex,n+1):  # цикл от текущего числа до последнего
                    comb.append(i)  # добавляем в комбинацию текущее число из цикла
                    backtrack(remain-1,comb,i+1)  # запускаем рекурсию
                    comb.pop()  # удаляем последнее число
            
        backtrack(k,[],1)  # вызываем бэктрекинг
        return sol  # возвращаем ответ
