class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        own_share = -prices[0] # own_share отвечает за ситуацию, когда мы владеем акцией, т.е., если покупать первую акцию, то мы уходим в минус на значение её стоимости
        no_share = 0 # no_share отвечает за ситуацию, когда мы акцией не владеем, т.е., если мы не покупаем первую акцию, то остаёмся с 0 доходом, но и в минус не уходим

        for price in prices:
            # параллельное присвоение необходимо для того, чтобы решение о покупке/продаже принималось только на основании результатов предыдущих итераций
            own_share, no_share = max(own_share, no_share-price),  # тут мы принимаем решение о том, что выгодней, остаться с купленной предыдущей акцией, либо же отмены этой покупки и приобретении текущей акции
                                  max(no_share, own_share + price - fee)  #  тут мы решаем, стоит ли сохранить результат предыдущей продажи, либо же отменить её и продать акцию в этот раз
        
        return no_share # возвращаем no_share, поскольку в итоге мы обязаны продать все акции, если их покупали
