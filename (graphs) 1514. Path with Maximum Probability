class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        g = defaultdict(list)  # создаём defaultdict, который будет создавать пустой список при обращении по несуществующему ключу
        
        dq = deque([start])  # создаём deque(очередь) из списка с одним элементом
        for i, (a, b) in enumerate(edges):  # перебираем пронумерованные рёбра графа из списка edges
            g[a].append([b, i]) # добавляем в список g(граф) пару значений: ключ элемента, являющийся первой вершиной ребра и индекс этой пары(нужно для обращения в списку succProb)
            g[b].append([a, i]) # добавляем в список g(граф) пару значений: ключ элемента, являющийся второй вершиной ребра и индекс этой пары(нужно для обращения в списку succProb)
            # с помощью этих двух строчек мы создаём словарь, который отображает все связи между элементами
        p = [0.0] * n  # создаём список p, который олицетворяет вероятности достижения конкретной вершины графа, изначально мы их не знаем, поэтому приравниваем к нулю
        p[start] = 1.0 # отсчёт начинается с точки start, поэтому вероятность попадания в неё равна 1.0(100%)
        while dq: # повторяем цикл, пока очередь не опустеет
            cur = dq.popleft()  # достаём из очереди номер наименьшей вершины
            for neighbor, i in g[cur]:  # перебираем всех соседей этой вершины
                if p[cur] * succProb[i] > p[neighbor]:  # если вероятность достижения нынешней точки, умноженная на эту 
                                                          вероятность из заранее известного списка больше вероятности достижения соседа
                    p[neighbor] = p[cur] * succProb[i]  # то меняем вероятность достижения соседа на произведение вероятности достижения нынешней точки с вероятностью достижения этой точки 
                                                          из заранее известного списка
                    dq.append(neighbor)  # добавляем в очередь соседа рассматриваемой точки
        return p[end]  # возвращаем искомый элемент из списка, в котором теперь хранятся максимальные вероятности достижения каждой из точек
