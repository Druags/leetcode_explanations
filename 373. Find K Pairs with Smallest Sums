class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        res_v = []  # в этой переменной хранятся пары, которые нам нужно вернуть
        pq = [] #  в этой переменной будут храниться пары значений (сумма, индекс элемента из второго списка)
        for x in nums1:  # перебираем первый список
            heapq.heappush(pq, (x + nums2[0], 0))  # с использованием heapq добавляем в pq пары значений 

        while k > 0 and pq: # этот цикл будет работать до тех пор, пока не наберётся необходимое количество искомых сумм, либо не кончится список
            s, pos = heapq.heappop(pq)  # распаковываем наименьшую пару чисел из списка, s - сумма, pos - позиция элемента из второго списка
            res_v.append([s-nums2[pos], nums2[pos]])  # добавляем в результат значения элементов, из которых состоит наименьшая сумма

            if pos + 1 < len(nums2):  #  проверяем, что не перебрали второй список до конца
                heapq.heappush(pq,(s-nums2[pos]+nums2[pos+1], pos+1))  # добавляем в список pq сумму нынешнего элемента из списка nums1 со следующим после pos элементом из nums2
            
            k-=1  # уменьшаем оставшееся количество сумм к поиску
        return res_v  # возвращаем список с искомыми суммами
